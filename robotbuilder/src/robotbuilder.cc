#include <metapod/robotbuilder/robotbuilder.hh>
#include <iostream>
#include <algorithm>
#include <cctype>
#include <boost/tokenizer.hpp>
#include <boost/filesystem/operations.hpp>
#include <metapod/tools/spatial.hh>

using namespace std;
namespace {

const int MAX_CHILDREN_PER_NODE = 5;
const char warning_c_str[] =
    "// This file has been generated by the metapod robotbuilder library.\n\n";

void createJoint(std::ofstream & joint_hh,
                 std::ofstream & init_cc,
                 const std::string & libname,
                 int joint_type,
                 const std::string & name,
                 int label,
                 int positionInConf,
                 const Eigen::Matrix3d & Xt_E,
                 const Eigen::Vector3d & Xt_r,
                 const std::string & tab,
                 const Eigen::Vector3d & axis)
{
  std::string libname_uc(libname);
  std::transform(libname.begin(), libname.end(), libname_uc.begin(), ::toupper);
  switch(joint_type)
  {
    case metapod::RobotBuilder::FREE_FLYER:
      joint_hh << tab << "JOINT_FREE_FLYER(" << libname_uc << ", " << name << ");\n";
      init_cc << tab << "INITIALIZE_JOINT_FREE_FLYER(" << name << ");\n";
      break;
    case metapod::RobotBuilder::REVOLUTE_AXIS_X:
      joint_hh << tab << "JOINT_REVOLUTE_AXIS_X(" << libname_uc << ", " << name << ");\n";
      init_cc << tab << "INITIALIZE_JOINT_REVOLUTE_AXIS_X(" << name << ");\n";
      break;
    case metapod::RobotBuilder::REVOLUTE_AXIS_ANY:
      joint_hh << tab << "JOINT_REVOLUTE_AXIS_ANY(" << libname_uc << ", " << name
          << ", " << axis[0] << ", " << axis[1] << ", " << axis[2] << ");\n";
      init_cc << tab << "INITIALIZE_JOINT_REVOLUTE_AXIS_ANY(" << name
          << ", " << axis[0] << ", " << axis[1] << ", " << axis[2] << ");\n";
      break;
  }
  init_cc
    << tab << "const std::string " << name << "::name = \"" << name << "\";\n"
    << tab << "const int " << name << "::label = " << label << ";\n"
    << tab << "const int " << name << "::positionInConf = " << positionInConf << ";\n"
    << tab << "const Spatial::Transform " << name << "::Xt = Spatial::Transform(\n"
    << tab << "  matrix3dMaker(\n"
    << tab << "    " << Xt_E(0,0) << ", " << Xt_E(0,1) << ", " << Xt_E(0,2) << ",\n"
    << tab << "    " << Xt_E(1,0) << ", " << Xt_E(1,1) << ", " << Xt_E(1,2) << ",\n"
    << tab << "    " << Xt_E(2,0) << ", " << Xt_E(2,1) << ", " << Xt_E(2,2) << "),\n"
    << tab << "  Vector3d(\n"
    << tab << "    " << Xt_r[0] << ", " << Xt_r[1] << ", " << Xt_r[2] << "));\n"
    << std::endl;
}

void createBody(std::ofstream & body_hh,
                std::ofstream & init_cc,
                const std::string & libname,
                const std::string & name,
                const std::string parent_name,
                const std::string joint_name,
                int label,
                double mass,
                const Eigen::Vector3d & CoM,
                const Eigen::Matrix3d & inertie,
                const std::string & tab)
{
  std::string libname_uc(libname);
  std::transform(libname.begin(), libname.end(), libname_uc.begin(), ::toupper);
  body_hh
    << tab << "CREATE_BODY("
      << libname_uc << ", "
      << name << ", "
      << parent_name << ", "
      << joint_name << ");\n";
  init_cc
    << tab << "INITIALIZE_BODY(" << name << ");\n"
    << tab << "const std::string " << name << "::name = \"" << name << "\";\n"
    << tab << "const int " << name << "::label = " << label << ";\n"
    << tab << "const FloatType " << name << "::mass = " << mass << ";\n"
    << tab << "const Vector3d " << name << "::CoM = Vector3d("
      << CoM[0] << ", "
      << CoM[1] << ", "
      << CoM[2] << ");\n"
    << tab << "const Matrix3d " << name << "::inertie = matrix3dMaker(\n"
    << tab << "  " << inertie(0,0) << ", " << inertie(0,1) << ", " << inertie(0,2) << ",\n"
    << tab << "  " << inertie(1,0) << ", " << inertie(1,1) << ", " << inertie(1,2) << ",\n"
    << tab << "  " << inertie(2,0) << ", " << inertie(2,1) << ", " << inertie(2,2) << ");\n"
    << tab << "Spatial::Inertia " << name << "::I = spatialInertiaMaker("
      << name << "::mass, "
      << name << "::CoM, "
      << name << "::inertie);\n"
    << std::endl;
}
}
namespace metapod {

RobotBuilder::RobotBuilder()
  : nb_dof_(0),
    nb_bodies_(0),
    node_depth_(0),
    is_initialized_(false),
    tab_size_(2),
    node_tab_size_(std::string("Node< ").length()),
    tab_(tab_size_, ' '),
    warning_(::warning_c_str)
{
  bodies_stack_.push_back(std::make_pair(std::string("NP"), 0));
}

RobotBuilder::~RobotBuilder()
{
  body_hh_ << namespaces_closing_;
  closeInclusionGuard(body_hh_, "BODY_HH");

  init_cc_ << namespaces_closing_;

  joint_hh_ << namespaces_closing_;
  closeInclusionGuard(joint_hh_, "JOINT_HH");

  std::string libname_uc(libname_);
  std::transform(libname_.begin(), libname_.end(), libname_uc.begin(),
      ::toupper);
  // finalize tree_ content
  while (!bodies_stack_.empty())
  {
    if (bodies_stack_.back().first != "NP")
    {
      closeNode();
      bodies_stack_.pop_back();
    }
    else
        break;
  }
  robot_hh_
      << "class " << libname_uc << "_DLLAPI Robot {\n"
      << "public:\n"
      << tab_ << "// Global constants or variable of the robot\n"
      << tab_ << "enum { NBDOF = " << nb_dof_ << " };\n"
      << tab_ << "enum { NBBODIES = " << nb_bodies_ << " };\n"
      << tab_ << "static Eigen::Matrix< FloatType, NBDOF, NBDOF > H;\n"
      << tab_ << "typedef Eigen::Matrix< FloatType, NBDOF, 1 > confVector;\n\n"
      << tab_ << "// Definition of the multibody tree as a type.\n"
      << tab_ << "typedef\n"
      << tree_.str() << " Tree;\n"
      << "};\n";
  robot_hh_ << namespaces_closing_;
  closeInclusionGuard(robot_hh_, "ROBOT_HH");
}

RobotBuilder::Status RobotBuilder::set_directory(const std::string & directory)
{
  if (is_initialized_)
  {
    std::cerr
        << "ERROR: one cannot call set_directory() after having called init()"
        << std::endl;
    return STATUS_FAILURE;
  }
  directory_ = directory;
  return STATUS_SUCCESS;
}

RobotBuilder::Status RobotBuilder::set_name(const std::string & name)
{
  if (is_initialized_)
  {
    std::cerr
        << "ERROR: one cannot call set_name() after having called init()"
        << std::endl;
    return STATUS_FAILURE;
  }
  name_ = name;
  return STATUS_SUCCESS;
}

RobotBuilder::Status RobotBuilder::set_libname(const std::string & libname)
{
  if (is_initialized_)
  {
    std::cerr
        << "ERROR: one cannot call set_libname() after having called init()"
        << std::endl;
  }
  libname_ = libname;
  return STATUS_SUCCESS;
}

RobotBuilder::Status RobotBuilder::set_namespace(const std::string & combined_namespace)
{
  if (is_initialized_)
  {
      std::cerr
          << "ERROR: one cannot call set_namespace() after having called "
          << "init()"
          << std::endl;
    return STATUS_FAILURE;
  }
  namespace_ = combined_namespace;// TODO: we should check namespace is valid
  typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
  boost::char_separator<char> sep(":"); // TODO: we should split at ::, not :
  tokenizer tokens(combined_namespace, sep);
  namespaces_.clear();
  std::stringstream opening;
  for (tokenizer::iterator tok_iter = tokens.begin();
       tok_iter != tokens.end();
       ++tok_iter)
  {
    namespaces_.push_back(*tok_iter);
    opening << "namespace " << *tok_iter << " {\n";
  }
  namespaces_opening_ = opening.str();
  std::stringstream closing;
  for (std::vector<std::string>::reverse_iterator rit = namespaces_.rbegin();
       rit != namespaces_.rend();
       ++rit)
  {
      closing << "} // closing namespace " << *rit << "\n";
  }
  namespaces_closing_ = closing.str();

  return STATUS_SUCCESS;
}

RobotBuilder::Status RobotBuilder::set_reinclusion_guard_prefix(const std::string& text)
{
  if (is_initialized_)
  {
    std::cerr
        << "ERROR: one cannot call set_reinclusion_guard_prefix() after having "
        << "called init()"
        << std::endl;
    return STATUS_FAILURE;
  }
  reinclusion_guard_prefix_ = text;
  return STATUS_SUCCESS;
}

RobotBuilder::Status RobotBuilder::set_license(const std::string& text)
{
  if (is_initialized_)
  {
    std::cerr
        << "ERROR: one cannot call set_license() after having called init()"
        << std::endl;
    return STATUS_FAILURE;
  }
  license_ = text;
  return STATUS_SUCCESS;
}

RobotBuilder::Status RobotBuilder::init()
{
  if (is_initialized_)
  {
    std::cerr << "ERROR: one can only call init() once" << std::endl;
    return STATUS_FAILURE;
  }

  boost::filesystem::create_directories(directory_);
  body_hh_.open(std::string(directory_ + "/body.hh").c_str());
  init_cc_.open(std::string(directory_ + "/" + name_ + ".cc").c_str());
  init_hh_.open(std::string(directory_ + "/" + name_ + ".hh").c_str());
  joint_hh_.open(std::string(directory_ + "/joint.hh").c_str());
  robot_hh_.open(std::string(directory_ + "/robot.hh").c_str());

  openInclusionGuard(body_hh_, "BODY_HH");
  body_hh_ << "# include \"metapod/tools/bodymacros.hh\"\n\n" // TODO: use "" or <> ?
           << namespaces_opening_;

  init_cc_
    << license_ << warning_
    << "# include \"" << name_ << ".hh\"\n\n"
    << namespaces_opening_;

  init_cc_
    << "\n"
    << "// Initialization of the robot global constants\n"
    << "Eigen::Matrix< FloatType, Robot::NBDOF, Robot::NBDOF > Robot::H;\n\n";

  init_hh_
    << license_ << warning_;
  openInclusionGuard(init_hh_, "INIT_HH");
  init_hh_
    << "# ifdef _MSC_VER\n"
    << "#  pragma warning( push )\n"
    << "// disable warning C4251: need to have DLL interface\n"
    << "// disable warning C4099: struct/class discrepancies\n"
    << "#  pragma warning( disable: 4251 4099 )\n"
    << "# endif\n"
    << "\n"
    << "# include \"robot.hh\"\n"
    << "\n"
    << "# ifdef _MSC_VER\n"
    << "#  pragma warning( pop )\n"
    << "# endif\n\n";
  closeInclusionGuard(init_hh_, "INIT_HH");

  joint_hh_
    << license_ << warning_;
  openInclusionGuard(joint_hh_, "JOINT_HH");
  joint_hh_
    << "# include \"metapod/tools/jointmacros.hh\"\n"
    << namespaces_opening_;

  robot_hh_
    << license_ << warning_;
  openInclusionGuard(robot_hh_, "ROBOT_HH");
  robot_hh_
    << "\n"
    << "# include \"config.hh\"\n"
    << "# include \"metapod/tools/common.hh\"\n"
    << "# include \"joint.hh\"\n"
    << "# include \"body.hh\"\n\n"
    << namespaces_opening_;

  is_initialized_ = true;
  return STATUS_SUCCESS;
}

void RobotBuilder::openInclusionGuard(
    std::ostream& stream,
    const char* name)
{
  stream << "#ifndef " << reinclusion_guard_prefix_ << name << "\n"
         << "# define " << reinclusion_guard_prefix_ << name << "\n\n";
}

void RobotBuilder::closeInclusionGuard(
  std::ostream& stream,
  const char* name)
{
  stream << "#endif // " << reinclusion_guard_prefix_ << name << "\n";
}

void RobotBuilder::closeNode()
{
  // restore indent
  --node_depth_;
  const std::string indent(tab_size_ + node_tab_size_ * node_depth_, ' ');
  tree_ << "\n" << indent << "    >";
}

Eigen::Vector3d RobotBuilder::defaultAxis()
{
  Eigen::Vector3d v = Eigen::Vector3d::Zero();
  v[0] = 1.;
  return v;
}

// parent_body_name: "NP" (no parent) or the parent body name
RobotBuilder::Status RobotBuilder::addLink(
    const std::string& parent_body_name,
    const std::string& joint_name,
    unsigned int joint_type,
    const Eigen::Matrix3d & joint_Xt_E,
    const Eigen::Vector3d & joint_Xt_r,
    const std::string& body_name,
    double body_mass,
    const Eigen::Vector3d & body_center_of_mass,
    const Eigen::Matrix3d & body_rotational_inertia,
    const Eigen::Vector3d & joint_axis)
{

  if (not is_initialized_)
  {
    std::cerr
        << "ERROR: one must call init() once before calling addSubTree()"
        << std::endl;
    return STATUS_FAILURE;
  }
  while (!bodies_stack_.empty())
  {
    if (parent_body_name != bodies_stack_.back().first)
    {
      closeNode();
      bodies_stack_.pop_back();
    }
    else
    {
      break;
    }
  }
  if (bodies_stack_.empty())
  {
    std::cerr
        << "ERROR: could not find a body named '" << parent_body_name
        << "' in the bodies stack. "
        << "Check the name and the order you add bodies in."
        << std::endl;
    return STATUS_FAILURE;
  }
  if (bodies_stack_.back().second >= ::MAX_CHILDREN_PER_NODE)
  {
    std::cerr
        << "ERROR: a node cannot have more than " << ::MAX_CHILDREN_PER_NODE
        << " children per node."
        << std::endl;
    return STATUS_FAILURE;
  }
  // TODO: check joint_name is a valid class name
  // TODO: check joint_Xt_E is a real rotation matrix
  // TODO: check body_name is a valid class name
  if (body_name == "NP")
  {
    std::cerr
        << "ERROR: one cannot name a body 'NP'. This name stands for "
        << "'no parent' and is reserved"
        << std::endl;
    return STATUS_FAILURE;
  }
  unsigned int joint_nb_dof;
  switch (joint_type) {
  case REVOLUTE_AXIS_ANY:
  case REVOLUTE_AXIS_X:
  {
    joint_nb_dof = 1;
    break;
  }
  case FREE_FLYER:
  {
    joint_nb_dof = 6;
    break;
  }
  default:
  {
    std::cerr
      << "ERROR: Joint '" << joint_name << "' is of unknown type"
      << std::endl;
    return STATUS_FAILURE;
  }
  }
  int joint_label = nb_bodies_;
  int body_label = nb_bodies_; // TODO: understand why body labels start at 0 in simple-humanoid
  int joint_position_in_conf = nb_dof_;
  ::createJoint(
      joint_hh_,
      init_cc_,
      libname_,
      joint_type,
      joint_name,
      joint_label,
      joint_position_in_conf,
      joint_Xt_E,
      joint_Xt_r,
      tab_,
      joint_axis);
  ::createBody(
      body_hh_,
      init_cc_,
      libname_,
      body_name,
      parent_body_name,
      joint_name,
      body_label,
      static_cast<metapod::FloatType>(body_mass),
      body_center_of_mass.cast<metapod::FloatType>(),
      body_rotational_inertia.cast<metapod::FloatType>(),
      tab_);
  ++nb_bodies_;
  nb_dof_ += joint_nb_dof;

  // start a new Node
  if (parent_body_name != "NP")
    tree_ << ",\n";
  const std::string indent(tab_size_ + node_tab_size_ * node_depth_, ' ');
  tree_ << indent << "Node< " << body_name << ",\n";
  // update the indentation accordingly
  ++node_depth_;
  // continue the Node with the joint name
  tree_ << indent << std::string(node_tab_size_, ' ') << joint_name;
  // update the bodies stack
  // increment the parent children count
  ++(bodies_stack_.back().second);
  // add the child to the stack
  bodies_stack_.push_back(std::make_pair(body_name, 0));
  return STATUS_SUCCESS;
}
}
