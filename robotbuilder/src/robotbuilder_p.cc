#include "robotbuilder_p.hh"
#include <iostream>
#include <cassert>
#include <algorithm>
#include <cctype>
#include <boost/regex.hpp>
#include <boost/algorithm/string/find_format.hpp>
#include <boost/algorithm/string/regex_find_format.hpp>
#include <boost/tokenizer.hpp>
#include <boost/filesystem/operations.hpp>
#include <metapod/tools/spatial.hh>

using namespace std;
namespace {

const int MAX_CHILDREN_PER_NODE = 5;
const char warning_c_str[] =
    "// This file has been generated by the metapod robotbuilder library.\n\n";

void createJoint(std::ostream & joint_hh,
                 std::ostream & init_cc,
                 const std::string & libname,
                 int joint_type,
                 const std::string & name,
                 int label,
                 int positionInConf,
                 const Eigen::Matrix3d & Xt_E,
                 const Eigen::Vector3d & Xt_r,
                 const std::string & tab,
                 const Eigen::Vector3d & axis)
{
  std::string libname_uc(libname);
  std::transform(libname.begin(), libname.end(), libname_uc.begin(), ::toupper);
  switch(joint_type)
  {
    case metapod::RobotBuilder::FREE_FLYER:
      joint_hh << tab << "JOINT_FREE_FLYER(" << libname_uc << ", " << name << ");\n";
      init_cc << tab << "INITIALIZE_JOINT_FREE_FLYER(" << name << ");\n";
      break;
    case metapod::RobotBuilder::REVOLUTE_AXIS_X:
      joint_hh << tab << "JOINT_REVOLUTE_AXIS_X(" << libname_uc << ", " << name << ");\n";
      init_cc << tab << "INITIALIZE_JOINT_REVOLUTE_AXIS_X(" << name << ");\n";
      break;
    case metapod::RobotBuilder::REVOLUTE_AXIS_ANY:
      joint_hh << tab << "JOINT_REVOLUTE_AXIS_ANY(" << libname_uc << ", " << name
          << ", " << axis[0] << ", " << axis[1] << ", " << axis[2] << ");\n";
      init_cc << tab << "INITIALIZE_JOINT_REVOLUTE_AXIS_ANY(" << name
          << ", " << axis[0] << ", " << axis[1] << ", " << axis[2] << ");\n";
      break;
  }
  init_cc
    << tab << "const std::string " << name << "::name = \"" << name << "\";\n"
    << tab << "const int " << name << "::label = " << label << ";\n"
    << tab << "const int " << name << "::positionInConf = " << positionInConf << ";\n"
    << tab << "const Spatial::Transform " << name << "::Xt = Spatial::Transform(\n"
    << tab << "  matrix3dMaker(\n"
    << tab << "    " << Xt_E(0,0) << ", " << Xt_E(0,1) << ", " << Xt_E(0,2) << ",\n"
    << tab << "    " << Xt_E(1,0) << ", " << Xt_E(1,1) << ", " << Xt_E(1,2) << ",\n"
    << tab << "    " << Xt_E(2,0) << ", " << Xt_E(2,1) << ", " << Xt_E(2,2) << "),\n"
    << tab << "  Vector3d(\n"
    << tab << "    " << Xt_r[0] << ", " << Xt_r[1] << ", " << Xt_r[2] << "));\n"
    << std::endl;
}

void createBody(std::ostream & body_hh,
                std::ostream & init_cc,
                const std::string & libname,
                const std::string & name,
                const std::string parent_name,
                const std::string joint_name,
                int label,
                double mass,
                const Eigen::Vector3d & CoM,
                const Eigen::Matrix3d & inertie,
                const std::string & tab)
{
  std::string libname_uc(libname);
  std::transform(libname.begin(), libname.end(), libname_uc.begin(), ::toupper);
  body_hh
    << tab << "CREATE_BODY("
      << libname_uc << ", "
      << name << ", "
      << parent_name << ", "
      << joint_name << ");\n";
  init_cc
    << tab << "INITIALIZE_BODY(" << name << ");\n"
    << tab << "const std::string " << name << "::name = \"" << name << "\";\n"
    << tab << "const int " << name << "::label = " << label << ";\n"
    << tab << "const FloatType " << name << "::mass = " << mass << ";\n"
    << tab << "const Vector3d " << name << "::CoM = Vector3d("
      << CoM[0] << ", "
      << CoM[1] << ", "
      << CoM[2] << ");\n"
    << tab << "const Matrix3d " << name << "::inertie = matrix3dMaker(\n"
    << tab << "  " << inertie(0,0) << ", " << inertie(0,1) << ", " << inertie(0,2) << ",\n"
    << tab << "  " << inertie(1,0) << ", " << inertie(1,1) << ", " << inertie(1,2) << ",\n"
    << tab << "  " << inertie(2,0) << ", " << inertie(2,1) << ", " << inertie(2,2) << ");\n"
    << tab << "Spatial::Inertia " << name << "::I = spatialInertiaMaker("
      << name << "::mass, "
      << name << "::CoM, "
      << name << "::inertie);\n"
    << std::endl;
}

// text of the template source files
extern "C" const char config_hh[];
extern "C" const size_t config_hh_len;
extern "C" const char body_hh[];
extern "C" const size_t body_hh_len;
extern "C" const char joint_hh[];
extern "C" const size_t joint_hh_len;
extern "C" const char robot_hh[];
extern "C" const size_t robot_hh_len;
extern "C" const char init_hh[];
extern "C" const size_t init_hh_len;
extern "C" const char init_cc[];
extern "C" const size_t init_cc_len;

// Functor that provides the replacement text given a match for use with
// boost::regex_replace.
// Match/replacement pairs are stored in a map.
// Boost.regex passes the functor by copy. To avoid copying map, we only store
// a reference.
class ReplFunctor
{
private:
  std::map<std::string, std::string> & map_;
public:
  ReplFunctor(std::map<std::string, std::string> & map):
      map_(map)
  {}
  template <typename IteratorT>
  std::string operator()(boost::algorithm::detail::regex_search_result<IteratorT> mm) const
  {
    boost::match_results<IteratorT> m = mm.match_results();
    std::string key = m[1].str();
    return map_[key];
  }
};

// helper function which writes a templated text. It loads the template text,
// and format it using regular expressions using replacement text provided in
// the map
void write_template(std::ostream& output,
                    const std::string& input,
                    std::map<std::string, std::string>& replacements)
{
  /*
    // construct the following string
    //  @((?:first_key)|(?:second_key)|(?:third_key))@
    std::stringstream expr;
    expr << "@((?:";
    std::map<std::string, std::string>::const_iterator last=map.end();
    --last; // point to the last element
    for (std::map<std::string, std::string>::const_iterator it=map.begin();
         it != last;
         ++it)
    {
      expr << it->first << ")|(?:";
    }
    expr << it->first << "))@";
    */
  boost::regex e("@(([a-zA-Z_][a-zA-Z0-9_]+))@");
  ReplFunctor formatter(replacements);
  std::string output_string = boost::algorithm::find_format_all_copy(
        input,
        boost::algorithm::regex_finder(e, boost::regex_constants::format_literal),
        formatter);
  output << output_string;
}

}

namespace metapod {

LinkData::LinkData(int id_=-1, int nb_children_=0):
  id(id_),
  nb_children(nb_children_)
{}

Link::Link(
      const std::string& parent_body_name_,
      const std::string& joint_name_,
      unsigned int joint_type_,
      const Eigen::Matrix3d & R_joint_parent_,
      const Eigen::Vector3d & r_parent_joint_,
      const std::string& body_name_,
      double body_mass_,
      const Eigen::Vector3d & body_center_of_mass_,
      const Eigen::Matrix3d & body_rotational_inertia_,
      const Eigen::Vector3d & joint_axis_,
      int dof_index_):
  parent_body_name(parent_body_name_),
  joint_name(joint_name_),
  joint_type(joint_type_),
  R_joint_parent(R_joint_parent_),
  r_parent_joint(r_parent_joint_),
  body_name(body_name_),
  body_mass(body_mass_),
  body_center_of_mass(body_center_of_mass_),
  body_rotational_inertia(body_rotational_inertia_),
  joint_axis(joint_axis_),
  dof_index(dof_index_)
  {}

void RobotBuilderP::reset_bodies_stack()
{
  bodies_stack_.clear();
  bodies_stack_.push_back(std::string("NP"));
}

RobotBuilderP::RobotBuilderP()
  : nb_dof_(0),
    nb_bodies_(0),
    node_depth_(0),
    is_initialized_(false),
    use_dof_index_(false),
    tab_size_(2),
    node_tab_size_(std::string("Node< ").length()),
    tab_(tab_size_, ' '),
    warning_(::warning_c_str)
{
  links_data_[std::string("NP")] = LinkData(-1, 0);
  reset_bodies_stack();
}

RobotBuilderP::~RobotBuilderP()
{
}

RobotBuilder::Status RobotBuilderP::set_directory(const std::string & directory)
{
  if (is_initialized_)
  {
    std::cerr
        << "ERROR: one cannot call set_directory() after having called addLink()"
        << std::endl;
    return RobotBuilder::STATUS_FAILURE;
  }
  directory_ = directory;
  return RobotBuilder::STATUS_SUCCESS;
}

RobotBuilder::Status RobotBuilderP::set_name(const std::string & name)
{
  if (is_initialized_)
  {
    std::cerr
        << "ERROR: one cannot call set_name() after having called addLink()"
        << std::endl;
    return RobotBuilder::STATUS_FAILURE;
  }
  name_ = name;
  return RobotBuilder::STATUS_SUCCESS;
}

RobotBuilder::Status RobotBuilderP::set_libname(const std::string & libname)
{
  if (is_initialized_)
  {
    std::cerr
        << "ERROR: one cannot call set_libname() after having called addLink()"
        << std::endl;
  }
  libname_ = libname;
  return RobotBuilder::STATUS_SUCCESS;
}

RobotBuilder::Status RobotBuilderP::set_use_dof_index(bool flag)
{
  if (is_initialized_)
  {
    std::cerr
        << "ERROR: one cannot call set_use_dof_index() after having called addLink()"
        << std::endl;
    return RobotBuilder::STATUS_FAILURE;
  }
  use_dof_index_ = flag;
  return RobotBuilder::STATUS_SUCCESS;
}

RobotBuilder::Status RobotBuilderP::set_license(const std::string& text)
{
  if (is_initialized_)
  {
    std::cerr
        << "ERROR: one cannot call set_license() after having called addLink()"
        << std::endl;
    return RobotBuilder::STATUS_FAILURE;
  }
  license_ = text;
  return RobotBuilder::STATUS_SUCCESS;
}

void RobotBuilderP::writeTemplate(
    const std::string& output_filename,
    const std::string& input_template)
{
  assert(is_initialized_);
  std::stringstream output_path;
  output_path << directory_ << "/" << output_filename;
  std::ofstream output_stream;
  output_stream.open(output_path.str().c_str());
  ::write_template(output_stream, input_template, replacements_);
  output_stream.close();
}


RobotBuilder::Status RobotBuilderP::init()
{
  assert(!is_initialized_);

  // set up the map of replacements (for the ones that are known
  // already).
  std::string libname_uc(libname_);
  std::transform(libname_.begin(), libname_.end(), libname_uc.begin(),
                 ::toupper);
  replacements_[std::string("LIBRARY_NAME")] = libname_uc;
  std::stringstream export_symbol;
  export_symbol << libname_ << "_EXPORTS";
  replacements_[std::string("EXPORT_SYMBOL")] = export_symbol.str();
  replacements_[std::string("ROBOT_NAMESPACE")] = name_;
  replacements_[std::string("ROBOT_NAME")] = name_;
  replacements_[std::string("LICENSE")] = license_;

  is_initialized_ = true;
  return RobotBuilder::STATUS_SUCCESS;
}

void RobotBuilderP::closeNode()
{
  // restore indent
  --node_depth_;
  const std::string indent(tab_size_ + node_tab_size_ * node_depth_, ' ');
  tree_ << "\n" << indent << "    >";
}

// parent_body_name: "NP" (no parent) or the parent body name
RobotBuilder::Status RobotBuilderP::addLink(
    const std::string& parent_body_name,
    const std::string& joint_name,
    unsigned int joint_type,
    const Eigen::Matrix3d & R_joint_parent,
    const Eigen::Vector3d & r_parent_joint,
    const std::string& body_name,
    double body_mass,
    const Eigen::Vector3d & body_center_of_mass,
    const Eigen::Matrix3d & body_rotational_inertia,
    const Eigen::Vector3d & joint_axis,
    int dof_index)
{

  if (!is_initialized_)
  {
    RobotBuilder::Status status = init();
    if (status == RobotBuilder::STATUS_FAILURE)
    {
      return RobotBuilder::STATUS_FAILURE;
    }
  }
  // check body_name
  if (body_name == "NP")
  {
    std::cerr
        << "ERROR: one cannot name a body 'NP'. This name stands for "
        << "'no parent' and is reserved"
        << std::endl;
    return RobotBuilder::STATUS_FAILURE;
  }
  // find an homonym
  std::map<std::string, LinkData>::iterator homonym_body =
      links_data_.find(body_name);
  if (homonym_body != links_data_.end())
  {
    std::cerr
        << "ERROR: there is already a body named '" << body_name << "'"
        << std::endl;
    return RobotBuilder::STATUS_FAILURE;
  }

  // TODO: check joint_Xt_E is a real rotation matrix
  // TODO: check body_name is a valid class name
  // TODO: check joint name
  // TODO: check joint_name is a valid class name

  // find the parent
  std::map<std::string, LinkData>::iterator parent =
      links_data_.find(parent_body_name);
  if (parent == links_data_.end())
  {
    std::cerr
        << "ERROR: could not find parent body named '" << parent_body_name << ". "
        << "Check the name and the order you add bodies in."
        << std::endl;
    return RobotBuilder::STATUS_FAILURE;
  }
  // check the user adds the links using a depth first traversal
  std::vector<std::string> bodies_stack = bodies_stack_; //FIXME: inefficient
  while (!bodies_stack.empty())
  {
    if (parent_body_name != bodies_stack.back())
    {
      bodies_stack.pop_back();
    }
    else
    {
      break;
    }
  }
  if (bodies_stack.empty())
  {
    std::cerr
        << "ERROR: could not find a parent body named '" << parent_body_name
        << "' in the bodies stack. "
        << "Check the name and the order you add bodies in: "
        << "it must be depth first."
        << std::endl;
     return RobotBuilder::STATUS_FAILURE;
  }
  bodies_stack_ = bodies_stack; //FIXME: inefficient

  if (parent->second.nb_children >= ::MAX_CHILDREN_PER_NODE)
  {
    std::cerr
        << "ERROR: a node cannot have more than " << ::MAX_CHILDREN_PER_NODE
        << " children per node."
        << std::endl;
    return RobotBuilder::STATUS_FAILURE;
  }

  // deal with joint type
  unsigned int joint_nb_dof;
  switch (joint_type) {
  case RobotBuilder::REVOLUTE_AXIS_ANY:
  case RobotBuilder::REVOLUTE_AXIS_X:
  {
    joint_nb_dof = 1;
    break;
  }
  case RobotBuilder::FREE_FLYER:
  {
    joint_nb_dof = 6;
    break;
  }
  default:
  {
    std::cerr
      << "ERROR: Joint '" << joint_name << "' is of unknown type"
      << std::endl;
    return RobotBuilder::STATUS_FAILURE;
  }
  }
  // deal with joint_index
  int joint_position_in_conf = -1;
  if (use_dof_index_)
  {
    if (dof_index < 0)
    {
      std::cerr
        << "ERROR: dof_index for joint '" << joint_name << "' is inconsitent"
        << std::endl;
      return RobotBuilder::STATUS_FAILURE;
    }
    joint_position_in_conf = dof_index;
  }
  else
  {
    joint_position_in_conf = nb_dof_;
  }
  // add the link for real
  links_.push_back(Link(
      parent_body_name,
      joint_name,
      joint_type,
      R_joint_parent,
      r_parent_joint,
      body_name,
      body_mass,
      body_center_of_mass,
      body_rotational_inertia,
      joint_axis,
      joint_position_in_conf));
  ++(parent->second.nb_children);
  bodies_stack_.push_back(body_name);
  links_data_[body_name] = LinkData(nb_bodies_, 0);
  ++nb_bodies_;
  nb_dof_ += joint_nb_dof;
  return RobotBuilder::STATUS_SUCCESS;
}

RobotBuilder::Status RobotBuilderP::writeLink(const Link &link)
{
  while (!bodies_stack_.empty())
  {
    if (link.parent_body_name != bodies_stack_.back())
    {
      closeNode();
      bodies_stack_.pop_back();
    }
    else
    {
      break;
    }
  }
  assert(!bodies_stack_.empty()); // there should be NP left at least
  int joint_label = links_data_[link.body_name].id;
  int body_label = joint_label;
  ::createJoint(
      joint_ss_,
      init_ss_,
      libname_,
      link.joint_type,
      link.joint_name,
      joint_label,
      link.dof_index,
      link.R_joint_parent,
      link.r_parent_joint,
      tab_,
      link.joint_axis);
  ::createBody(
      body_ss_,
      init_ss_,
      libname_,
      link.body_name,
      link.parent_body_name,
      link.joint_name,
      body_label,
      static_cast<metapod::FloatType>(link.body_mass),
      link.body_center_of_mass.cast<metapod::FloatType>(),
      link.body_rotational_inertia.cast<metapod::FloatType>(),
      tab_);
  // start a new Node
  if (link.parent_body_name != "NP")
    tree_ << ",\n";
  const std::string indent(tab_size_ + node_tab_size_ * node_depth_, ' ');
  tree_ << indent << "Node< " << link.body_name << ",\n";
  // update the indentation accordingly
  ++node_depth_;
  // continue the Node with the joint name
  tree_ << indent << std::string(node_tab_size_, ' ') << link.joint_name;
  // update the bodies stack
  // add the child to the stack
  bodies_stack_.push_back(link.body_name);
  return RobotBuilder::STATUS_SUCCESS;
}

RobotBuilder::Status RobotBuilderP::write()
{
  if (!is_initialized_)
  {
    return RobotBuilder::STATUS_FAILURE;
  }
  // create the directory (and its parents if necessary)
  boost::filesystem::create_directories(directory_);

  // add the links
  reset_bodies_stack();
  for (std::vector<Link>::const_iterator it = links_.begin();
      it != links_.end();
      ++it)
  {
    RobotBuilder::Status status = writeLink(*it);
    if (status == RobotBuilder::STATUS_FAILURE)
    {
      return RobotBuilder::STATUS_FAILURE;
    }
  }

  // finalize tree_ content
  while (!bodies_stack_.empty())
  {
    if (bodies_stack_.back() != "NP")
    {
      closeNode();
      bodies_stack_.pop_back();
    }
    else
        break;
  }
  // complete the replacements map
  replacements_[std::string("joint_definitions")] = joint_ss_.str();
  replacements_[std::string("body_definitions")] = body_ss_.str();
  std::stringstream nb_dof_ss;
  nb_dof_ss << nb_dof_;
  replacements_[std::string("ROBOT_NB_DOF")] = nb_dof_ss.str();
  std::stringstream nb_bodies_ss;
  nb_bodies_ss << nb_bodies_;
  replacements_[std::string("ROBOT_NB_BODIES")] = nb_bodies_ss.str();
  replacements_[std::string("nodes_tree")] = tree_.str();
  replacements_[std::string("init_joints_and_bodies")] = init_ss_.str();

  // generate files from template and replacements
  const std::string config_hh_templ(::config_hh, ::config_hh_len);
  writeTemplate(std::string("config.hh"), config_hh_templ);

  const std::string joint_hh_templ(::joint_hh, ::joint_hh_len);
  writeTemplate(std::string("joint.hh"), joint_hh_templ);

  const std::string body_hh_templ(::body_hh, ::body_hh_len);
  writeTemplate(std::string("body.hh"), body_hh_templ);

  const std::string robot_hh_templ(::robot_hh, ::robot_hh_len);
  writeTemplate(std::string("robot.hh"), robot_hh_templ);

  const std::string init_hh_templ(::init_hh, ::init_hh_len);
  writeTemplate(name_ + ".hh", init_hh_templ);

  const std::string init_cc_templ(::init_cc, ::init_cc_len);
  writeTemplate(name_ + ".cc", init_cc_templ);
  return RobotBuilder::STATUS_SUCCESS;
}

}
