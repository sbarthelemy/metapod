// Copyright 2013
//
// Sébastien Barthélémy (Aldebaran Robotics)
//
// This file is part of metapod.
// metapod is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// metapod is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// You should have received a copy of the GNU Lesser General Public License
// along with metapod.  If not, see <http://www.gnu.org/licenses/>.

// This program converts an `input-file` into a C array of character literals
// saved in a C source file. The source file can then be included in a C or C++
// application.

#include <iostream>
#include <fstream>
#include <iterator>
#include <boost/program_options.hpp>

enum Status
  {
    STATUS_SUCCESS = 0,
    STATUS_FAILURE = 1
  };

Status embedfile(const std::string & output, const std::string & input,
              const std::string & name)
{

  std::ofstream out;
  out.open(output.c_str());
  if (!out.is_open())
  {
    std::cerr << "could not open '" << output << "'" << std::endl;
    return STATUS_FAILURE;
  }
  std::ifstream in;
  in.open(input.c_str());
  if (!in.is_open())
  {
    std::cerr << "could not open '" << input << "'" << std::endl;
    return STATUS_FAILURE;
  }
  out << "// this file was generated by embedfile\n\n"
      << "#include <stdlib.h>\n\n"
      << "const char " << name << "[] = {\n";
  int columns = 0;
  while(!in.eof())
  {
    if (columns > 12)
    {
      out << "\n";
      columns = 0;
    }
    char c;
    in.get(c);
    out << " " << std::hex << std::showbase
        << static_cast<int>(static_cast<unsigned char>(c)) << ",";
    ++columns;
  }
  out << "};\n\n";
  out << "const size_t " << name << "_len = sizeof(" << name << ");";
  out.close();
  in.close();
  return STATUS_SUCCESS;
}

namespace po = boost::program_options;

int main(int argc, char** argv)
{
  // Declare a group of options that will be
  // allowed only on command line
  po::options_description generic("");
  // declare the options.
  // output-file, input-file and name are mandatory.
  // Once we can assume boost >= 1.42, we should declare them with
  // po::value<std::string>()->required() instead of just
  // po::value<std::string>()
  generic.add_options()
    ("help", "produce help message")
    ("output-file", po::value<std::string>(),
     "output file, to be added as a C source file")
    ("input-file", po::value<std::string>(),
     "input file")
    ("name", po::value<std::string>(),
     "variable that will hold the data");

  po::options_description cmdline_options;
  cmdline_options.add(generic);

  po::positional_options_description pos;
  pos.add("output-file", 1);
  pos.add("input-file", 1);
  pos.add("name", 1);
  po::variables_map vm;
  po::options_description visible(
      "Usage: embedfile [options] output-file intput-file name\n\n"
      "Convert `input-file` into a C array of character literals saved in\n"
      "variable `name` in C source file `output-file`. The array length is\n"
      "saved in variable `name`_len.\n\n"
      "The array can then be used in a C++ application such as:\n\n"
      "  #include <iostream>\n"
      "  extern \"C\" const char foo[];\n"
      "  extern \"C\" const size_t foo_len;\n"
      "  int main()\n"
      "  {\n"
      "      std::cout << std::string(foo, foo_length) << std::flush;\n"
      "  }\n\n"
      "Options:");
  visible.add(generic);

  try {
    po::store(po::command_line_parser(argc, argv).
            options(cmdline_options).positional(pos).run(), vm);
    if (vm.count("help"))
    {
      std::cout << visible << "\n";
      return STATUS_SUCCESS;
    }
    // deal with mandatory options
    // with boost >= 1.42, we'll declare these options as required and
    // this check won't be necessary anymore.
    if (vm.count("output-file") == 0 ||
        vm.count("input-file") == 0 ||
        vm.count("name") == 0)
    {
      std::cout << visible << "\n";
      return STATUS_FAILURE;
    }
    po::notify(vm);
  }
  catch(boost::program_options::error)
  {
    std::cout << visible << "\n";
    return STATUS_FAILURE;
  }
  return embedfile(
      vm["output-file"].as<std::string>(),
      vm["input-file"].as<std::string>(),
      vm["name"].as<std::string>());
}
